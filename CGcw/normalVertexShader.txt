cbuffer staticMeshBuffer {
    float4x4 VP;         // View-Projection Matrix
    float4x4 world;      // World Matrix
    float3 lightPos;     // Light Position
};

struct VS_INPUT {
    float3 Pos : POS;
    float3 Normal : NORMAL;
    float3 Tangent : TANGENT;
    float2 TexCoords : TEXCOORD;
};

struct PS_INPUT {
    float4 Pos : SV_POSITION;
    float2 TexCoords : TEXCOORD;
    float3 TangentToLight : TEXCOORD1; // Light direction in tangent space
    float3 TangentToView : TEXCOORD2;  // View direction in tangent space
};

float3x3 inverse(float3x3 m) {
    float det = m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) -
                m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
                m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);

    if (abs(det) < 1e-6) return m; // Handle near-zero determinant

    float invDet = 1.0 / det;

    float3x3 result;
    result[0][0] = invDet * (m[1][1] * m[2][2] - m[1][2] * m[2][1]);
    result[0][1] = invDet * (m[0][2] * m[2][1] - m[0][1] * m[2][2]);
    result[0][2] = invDet * (m[0][1] * m[1][2] - m[0][2] * m[1][1]);

    result[1][0] = invDet * (m[1][2] * m[2][0] - m[1][0] * m[2][2]);
    result[1][1] = invDet * (m[0][0] * m[2][2] - m[0][2] * m[2][0]);
    result[1][2] = invDet * (m[0][2] * m[1][0] - m[0][0] * m[1][2]);

    result[2][0] = invDet * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
    result[2][1] = invDet * (m[0][1] * m[2][0] - m[0][0] * m[2][1]);
    result[2][2] = invDet * (m[0][0] * m[1][1] - m[0][1] * m[1][0]);

    return result;
}

PS_INPUT VS(VS_INPUT input) {
    PS_INPUT output;

    // Transform position
    float4 worldPos = mul(input.Pos, world);
    output.Pos = mul(worldPos, VP);

    // Pass texture coordinates
    output.TexCoords = input.TexCoords;

    // Tangent space basis
    float3x3 worldInverse = (float3x3)inverse(world); // Only inverse, no transpose
    float3 T = normalize(mul(input.Tangent, worldInverse));
    float3 N = normalize(mul(input.Normal, worldInverse));
    float3 B = normalize(cross(N, T)); // Bitangent

    // Light direction in world space
    float3 lightDir = normalize(lightPos - worldPos.xyz);

    // View direction in world space (assuming camera at origin)
    float3 viewDir = normalize(-worldPos.xyz);

    // Transform directions into tangent space
    output.TangentToLight.x = dot(lightDir, T);
    output.TangentToLight.y = dot(lightDir, B);
    output.TangentToLight.z = dot(lightDir, N);

    output.TangentToView.x = dot(viewDir, T);
    output.TangentToView.y = dot(viewDir, B);
    output.TangentToView.z = dot(viewDir, N);

    return output;
}